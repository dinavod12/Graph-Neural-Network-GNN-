# -*- coding: utf-8 -*-
"""GNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18o5mgXyu7pujGFtfgrIxAISjhQpXcW0D
"""



import pandas as pd
import numpy as np

dtype_anime={
    'Name':'category',
    'anime_id':np.int32,
    'Episodes':'category',
    'sypnopsis':'category',
    'English name':'category',
    'Type':'category',
    'Japanese name':'category',
    'Aired':'category',
    'Premiered':'category',
    "Producers":'category',
    'Licensors':"category",
    'Studios':"category",
    'Source':'category',
    'Duration':'category',
    'Rating':'category',
    'Ranked':np.float32,
    'Popularity':np.int32,
    'Members':np.int32,
    'Favorites':np.int32,
    'Watching':np.int32,
    'Completed':np.int32,
    'On-Hold':np.int32,
    'Dropped':np.int32,
    'Score':np.float32,
    'Genres':'category'}

dtypes_user={
    'user_id':np.int32,
    'anime_id':np.int32,
    'rating':np.int32}

df_anime_filtered = pd.read_csv("/content/drive/MyDrive/anime_filtered.csv")

from google.colab import drive
drive.mount('/content/drive')

df_anime_filtered.head()

pip install torch

import torch

# We can define a sentence encoder that encodes raw column strings into low-dimensional embeddings.
# For this, we make use of the excellent sentence-transformers library which provides a large number of state-of-the-art pretrained NLP embedding models:

pip install sentence-transformers

df = pd.read_csv("/content/drive/MyDrive/user_filtered.csv")
df.head()

s1 = set(df["anime_id"])
s2 = set(df_anime_filtered["anime_id"])
val = list(s2-s1)
print(val)
for i in val:
  print(i)
  filt = df_anime_filtered["anime_id"] == i
  df_anime_filtered = df_anime_filtered.drop(index = df_anime_filtered[filt].index)
len(set(df_anime_filtered["anime_id"]))

df_anime_filtered.to_csv("/content/drive/MyDrive/anime_filtered.csv")

df_anime_filtered = pd.read_csv("/content/drive/MyDrive/anime_filtered.csv")

# For representing this data in the PyG data format, we first define a method load_node_csv() that reads in a *.csv file .
# And returns a node-level feature representation x of shape [num_nodes, num_features]

def load_node_csv(path,index_col,encoders=None,**kwargs):
    df = pd.read_csv(path,index_col = index_col,**kwargs)
    mapping = {index:i for i,index in enumerate(df.index.unique())}
    x = None
    if encoders is not None:
        xs = [encoder(df[col]).to('cuda:0') for col,encoder in encoders.items()]
        x = torch.cat(xs,dim=-1)
    return x,mapping

# The SequenceEncoder class loads a pre-trained NLP model as given by model_name, and uses it to encode a list of strings into a PyTorch tensor of shape [num_strings, embedding_dim].
# We can use this SequenceEncoder to encode the English Name of the anime_filtered.csv file.

# In a similar fashion, we can create another encoder that converts the genres of anime.
# For e.g., Adventure|Children|Fantasy, into categorical labels.
#For this, we first need to find all existing genres present in the data, create a feature representation x of shape [anime_x,anime_mapping],
#  and assign a 1 to x[i, j] in case the genre j is present in anime i:

from sentence_transformers import SentenceTransformer

class SequenceEncoder:
    def __init__(self,model_name = "all-MiniLM-L6-v2"):
        self.model = SentenceTransformer(model_name)

    @torch.no_grad()

    def __call__(self,df):
        x = self.model.encode(df.values,show_progress_bar=True,convert_to_tensor = True)
        return x

class GenresEncoder:

    def __init__(self,sep="|"):
        self.sep = sep
    def __call__(self,df):
        genres = set(g for col in df.values for g in col.split(self.sep))
        mapping = {genre : i for i,genre in enumerate(genres)}
        x = torch.zeros(len(df),len(mapping))

        for i,col in enumerate(df.values):
            for genre in col.split(self.sep):
                x[i,mapping[genre]] = 1
        return x

anime_x,anime_mapping = load_node_csv("/content/drive/MyDrive/anime_filtered.csv",index_col = "anime_id",encoders = {
    "English name":SequenceEncoder(),
    "Genres":GenresEncoder()
})

# Similarly, we can utilize load_node_csv() for obtaining a user mapping from userId to consecutive values as well.
# However, there is no additional feature information for users present in this dataset. As such, we do not define any encoders:

_,user_mapping = load_node_csv("/content/drive/MyDrive/user_filtered.csv",index_col = "user_id")

# Installing Pytorch-Geometric

pip install torch_geometric

# Now we are ready to initialize our HeteroData object and pass two node types into it:

from torch_geometric.data import HeteroData

data = HeteroData()
data["user"].num_node = len(user_mapping)
data["anime"].x = anime_x

print(data)

# Now Next edge
# Here we take a look at connecting users with anime movies as defined by their rating.
#For this, we define a method load_edge_csv() that returns the final edge_index representation of shape [2, num_ratings]

from pandas.core.internals.base import default_index
lst_anime_mapping = list(anime_mapping.keys())
def load_edge_csv(path,source_index_col,source_mapping,destination_index_col,destination_mapping,encoders = None,**kwargs):
    df = pd.read_csv(path,**kwargs)
    #try:
    source = [source_mapping[index] for index in df[source_index_col]]
    destination = [destination_mapping[index] for index in df[destination_index_col] ]

    #val = len(source)-len(destination)
    #source = source-val

    edge_index = torch.tensor([source,destination])
    edge_attr = None

    if encoders is not None:
        edge_attr = [encoder(df[col]) for col,encoder in encoders.items()]
        edge_attrs = torch.cat(edge_attr,dim=-1)

    return edge_index,edge_attrs

# Similarly to load_node_csv(), encoders are used to return additional edge-level feature information.
# Similarly here we are using IdentityEncoder that simply converts a list of point values into a PyTorch tensor:

class IdentityEncoder:

    def __init__(self):
        pass
    def __call__(self,df):
        return torch.from_numpy(df.values).view(-1,1).to(torch.long)

# With this, we are ready to finalize our HeteroData object:

edge_index, edge_label = load_edge_csv(
    "/content/drive/MyDrive/user_filtered.csv",
    source_index_col='user_id',
    source_mapping=user_mapping,
    destination_index_col="anime_id",
    destination_mapping=anime_mapping,
    encoders={'rating': IdentityEncoder()},
)

data['user', 'rates', 'movie'].edge_index = edge_index
data['user', 'rates', 'movie'].edge_label = edge_label

print(data)